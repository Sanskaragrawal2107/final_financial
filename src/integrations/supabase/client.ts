
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { MaterialItem, BankDetails } from '@/lib/types';

const SUPABASE_URL = "https://bpyzpnioddmzniuikbsn.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJweXpwbmlvZGRtem5pdWlrYnNuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE3ODE0MzksImV4cCI6MjA1NzM1NzQzOX0.UEdE77tebNbCdJkmX0RyNpKVp3mWhTL-hekMVNcPuIg";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Helper function for incrementing values
if (!supabase.rpc) {
  // Create a placeholder rpc function if it doesn't exist
  // This will be replaced by the real implementation when Supabase is initialized
  console.warn("RPC function not available, using fallback implementation");
}

// RPC helper to increment a column value
export const incrementValue = async (value: number, rowId: string, columnName: string) => {
  try {
    // Using direct update instead of rpc
    const { data, error } = await supabase
      .from('sites')
      .update({ [columnName]: value })
      .eq('id', rowId)
      .select();
      
    if (error) throw error;
    return data;
  } catch (error) {
    console.error("Error incrementing value:", error);
    throw error;
  }
};

// Function to fetch site invoices
export const fetchSiteInvoices = async (siteId: string) => {
  try {
    console.log("Fetching invoices for site:", siteId);
    const { data, error } = await supabase
      .from('site_invoices')
      .select('*')
      .eq('site_id', siteId);
      
    if (error) {
      console.error('Error fetching invoices:', error);
      return [];
    }
    
    if (!data || data.length === 0) {
      console.log("No invoices found for site:", siteId);
      return [];
    }
    
    console.log("Found invoices:", data.length);
    
    return data.map(invoice => {
      // Parse material_items from JSON
      let parsedMaterialItems: MaterialItem[] = [];
      try {
        if (invoice.material_items) {
          parsedMaterialItems = (typeof invoice.material_items === 'string') 
            ? JSON.parse(invoice.material_items as string) 
            : (invoice.material_items as unknown as MaterialItem[]);
        }
      } catch (e) {
        console.error('Error parsing material items:', e);
      }
      
      // Parse bank_details from JSON
      let parsedBankDetails: BankDetails = {
        accountNumber: '',
        bankName: '',
        ifscCode: ''
      };
      try {
        if (invoice.bank_details) {
          parsedBankDetails = (typeof invoice.bank_details === 'string')
            ? JSON.parse(invoice.bank_details as string)
            : (invoice.bank_details as unknown as BankDetails);
        }
      } catch (e) {
        console.error('Error parsing bank details:', e);
      }
      
      return {
        id: invoice.id,
        date: new Date(invoice.date),
        partyId: invoice.party_id,
        partyName: invoice.party_name,
        material: invoice.material,
        quantity: Number(invoice.quantity),
        rate: Number(invoice.rate),
        gstPercentage: Number(invoice.gst_percentage),
        grossAmount: Number(invoice.gross_amount),
        netAmount: Number(invoice.net_amount),
        materialItems: parsedMaterialItems,
        bankDetails: parsedBankDetails,
        billUrl: invoice.bill_url,
        paymentStatus: invoice.payment_status as any,
        createdBy: invoice.created_by || '',
        createdAt: new Date(invoice.created_at),
        approverType: invoice.approver_type as "ho" | "supervisor" || "ho",
        siteId: invoice.site_id || ''
      };
    });
  } catch (error) {
    console.error('Error:', error);
    return [];
  }
};

// Calculate site financial summary
export const calculateSiteFinancialSummary = async (siteId: string) => {
  console.log("Calculating financial summary for site:", siteId);
  
  try {
    // Fetch all the necessary data in parallel
    const [siteData, expensesData, advancesData, invoicesData] = await Promise.all([
      // Get site funds
      supabase.from('sites').select('funds, total_funds').eq('id', siteId).single(),
      
      // Get expenses
      supabase.from('expenses').select('amount').eq('site_id', siteId),
      
      // Get advances
      supabase.from('advances').select('amount, purpose').eq('site_id', siteId),
      
      // Get invoices
      supabase.from('site_invoices').select('net_amount, payment_status').eq('site_id', siteId)
    ]);
    
    // Handle any errors
    if (siteData.error) {
      console.error('Error fetching site data:', siteData.error);
      return null;
    }
    
    if (expensesData.error) {
      console.error('Error fetching expenses:', expensesData.error);
      return null;
    }
    
    if (advancesData.error) {
      console.error('Error fetching advances:', advancesData.error);
      return null;
    }
    
    if (invoicesData.error) {
      console.error('Error fetching invoices:', invoicesData.error);
      return null;
    }
    
    // Calculate totals
    const fundsReceived = Number(siteData.data?.total_funds || 0);
    
    const totalExpenditure = expensesData.data?.reduce((sum, expense) => 
      sum + Number(expense.amount), 0) || 0;
    
    // Calculate regular advances (excluding debits to worker)
    const totalAdvances = advancesData.data?.reduce((sum, advance) => {
      // Check if the purpose is not one of the debit purposes
      const isDebitPurpose = ['safety_shoes', 'tools', 'other'].includes(advance.purpose);
      return isDebitPurpose ? sum : sum + Number(advance.amount);
    }, 0) || 0;
    
    // Calculate debits to worker (specific advance purposes)
    const debitsToWorker = advancesData.data?.reduce((sum, advance) => {
      // Check if the purpose is a debit purpose
      const isDebitPurpose = ['safety_shoes', 'tools', 'other'].includes(advance.purpose);
      return isDebitPurpose ? sum + Number(advance.amount) : sum;
    }, 0) || 0;
    
    // Calculate invoices paid
    const invoicesPaid = invoicesData.data?.reduce((sum, invoice) => 
      invoice.payment_status === 'paid' ? sum + Number(invoice.net_amount) : sum, 0) || 0;
    
    // Calculate pending invoices
    const pendingInvoices = invoicesData.data?.reduce((sum, invoice) => 
      invoice.payment_status === 'pending' ? sum + Number(invoice.net_amount) : sum, 0) || 0;
    
    // Calculate total balance
    const totalBalance = fundsReceived - totalExpenditure - totalAdvances - invoicesPaid;
    
    console.log("Financial summary calculated:", {
      fundsReceived,
      totalExpenditure,
      totalAdvances,
      debitsToWorker,
      invoicesPaid,
      pendingInvoices,
      totalBalance
    });
    
    return {
      fundsReceived,
      totalExpenditure,
      totalAdvances,
      debitsToWorker,
      invoicesPaid,
      pendingInvoices,
      totalBalance
    };
  } catch (error) {
    console.error('Error calculating financial summary:', error);
    return null;
  }
};
